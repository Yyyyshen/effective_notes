// more_effective_cpp_04.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

/**
 * 效率
 */

using namespace std;

//条款16：谨记80-20法则
// 
//一个程序80%的资源用于20%的代码上
// 资源指的是执行时间、内存、磁盘访问、维护成本等
// 也有人赞同90-10法则，但宗旨就是软件整体性能取决于一小部分代码
//


//条款17：考虑使用lazy evaluation（缓式评估）
// 
//最具效率的就是未被执行的运算
// 直到某种运算结果必须立马被需要之前，都应尽量拖延
// 
//常用四种情况：
// 在真正需要之前，不必急于给某物做一个副本
// 延缓决定读和写
// 缓式取出，在需要时才在member functions内赋值（包括const成员函数），所以可以将data members声明为mutable 指针字段
// 表达式缓评估
//


//条款18：分期摊还预计的计算成本
// 
//如果预期程序常常会用到某个计算，可以降低每次计算的平均成本，办法就是设计一份数据结构以便有效率地处理需求
//可以成为超前评估——over-eager evaluation
template<class numerical_type>
class data_collection {
public:
	numerical_type min() const {};
	numerical_type max() const {};
	//...
};
//当这样地调用很频繁时，可以随时记录程序执行过程中数据集的各种操作
//一旦函数被调用，便可以立即返回正确的值，而无须再计算，这样分次摊还的成本会更低
//（例如vector中，当容量即将不够用时，进行双倍扩容，提前分配更多内存，这样就避免了每次添加都再次扩容的资源消耗）
//这与条例17并不矛盾
// 当必须支持某些运算而结果并不总是需要时，缓式评估可以改善效率
// 当必须支持某些运算并且结果几乎总是被需要时，超前评估可以改善效率
//


//条款19：了解临时对象来源
// 
//
//


int main()
{
	std::cout << "Hello World!\n";
}
